一句话：“业务语义上，这条‘子’数据能不能被多个‘父’共享？”

场景关系理由
一篇 Post 只能出现在一个 Blog 下一对多Post 是 Blog 的“私有子数据”，不可共享
一篇 Post 需要被多个 Blog 引用（合集、转载、共享库）多对多Post 是“独立资源”，可被多个 Blog 共用

只要出现 “同一实例想归属多个父” 的需求，立刻用多对多；否则一对多足够。
| 对比维度 | 多对多（自动中间表） | 拆成两个一对多（显式中间表） |
|-----------|-----------------------|-----------------------------|
| 表结构 | EF Core 按约定生成一张隐藏的中间表（如 PostTag），只包含两侧主键，无实体类。 | 手动创建一张“连接实体”表（如 UserModule），有对应的实体类，可加额外字段。 |
| 导航属性 | 两侧实体直接拥有对方集合：`User.Modules`、`Module.Users`，查询一条 LINQ 即可。 | 两侧实体不再直接持有对方集合，必须通过中间实体两次查询或手动 Join。 |
| 查询写法 | `context.Users.Include(u => u.Modules)` 一条语句完成。 | 需 `context.UserModules.Where(um => um.UserId == id).Select(um => um.Module)` 两段。 |
| 额外字段 | 无法在隐藏中间表里加字段（如授权时间、权限级别）。 | 可在 UserModule 里自由加字段，扩展业务属性。 |
| 迁移与维护 | 迁移脚本由 EF Core 自动管理，表名、约束不可控。 | 表结构完全由开发者控制，字段、索引、约束均可自定义。 |
| 性能 | 简单多对多查询性能最佳，EF Core 可优化为单条 SQL。 | 多一次 Join，复杂查询可能变慢，但可针对中间表建索引优化。 |
| 适用场景 | 只需纯粹“多选”关系，且两侧实体经常双向查询。 | 需要记录关联的附加信息，或业务逻辑要求显式中间实体。 |

一句话总结  
自动中间表让模型更简洁、查询更短；显式拆成一对多则牺牲了导航便利，换来了字段扩展与结构可控。


### 一句话总结  
“先插主、后插从，只赋自然键，让 EF 去推断外键；绝不手写 AId，绝不 new 导航实体。”

---

### 逐句拆解 & 详细说明

| 口诀 | 含义 | 技术细节 | 违反后果 |
|---|---|---|---|
| **先插主** | 主实体 A 必须先被 `Add` 或已存在于数据库 | `dbContext.As.Add(a);` 使 A 进入 `Added` 状态，EF 才能级联处理其子实体 | 若 A 未跟踪，B 的 AId 永远为 0，保存时报“无法插入 NULL”或“外键冲突” |
| **后插从** | 在 A 被跟踪之后，再向 `a.Bs` 集合添加子实体 | 顺序：`new A` → `Add(a)` → `a.Bs.Add(new B { ... })` | 顺序颠倒不会出错，但提前 Add 可读性更好，且避免重复附加 |
| **只赋自然键** | 只给 B 赋“业务无关”的自然键（如 CId），**绝不手动写 AId** | `new B { CId = 1 }` 即可；AId 由 EF 在 `SaveChanges` 时自动回填 | 手写 `AId = a.Id` 时若 `a.Id == 0` 会插入 0，触发外键约束失败 |
| **让 EF 去推断外键** | 依赖导航集合 `a.Bs` 反向推断 `B.A = a`，从而生成正确的 SQL | EF Core 在检测到 `a.Bs.Add(b)` 后，会把 `b.AId` 标记为 `a` 的主键值（即使此时为临时值） | 若绕过集合直接 `context.Bs.Add(b)`，且未设置 `b.A`，则 AId 丢失 |
| **绝不手写 AId** | 代码里不出现 `AId = x` 的赋值 | 把 AId 属性设为 `private set` 或干脆去掉，强制只能通过导航属性建立关系 | 手写 AId 会把“临时值”固化成 0，导致插入失败 |
| **绝不 new 导航实体** | 不要 `new C { Id = 1 }` 来充当已有数据 | 若 C 已存在，只赋 `CId`；若需要导航属性，用 `context.Cs.Attach(new C { Id = 1 })` 先附加 | 直接 `new C` 会被 EF 视为新增，结果多出一条 `INSERT C` 语句，主键冲突或脏数据 |

---

### 最小、最安全的代码模板

```csharp
// 1. 建主
var a = new A { Name = "New A" };

// 2. 建从（只给自然键）
foreach (var cId in new[] { 1, 2, 3 })
    a.Bs.Add(new B { CId = cId });

// 3. 一次性跟踪
dbContext.As.Add(a);          // 级联跟踪所有 B
await dbContext.SaveChangesAsync(); // EF 自动回填 AId
```

---

### 常见踩坑速查

| 错误写法 | 现象 | 修正 |
|---|---|---|
| `a.Bs.Add(new B { AId = a.Id, CId = 1 })` | 插入 0 或负值，外键失败 | 删掉 `AId = a.Id` |
| `new B { C = new C { Id = 1 } }` | EF 尝试插入新 C，主键冲突 | 改为 `new B { CId = 1 }` 或先 `Attach` |
| 更新时直接 `a.Bs.Clear(); a.Bs.Add(...)` | 旧数据未删除，出现重复 | 先 `Load(a.Bs)` 再对比差异，或手工 `RemoveRange` |
| 并发场景把 B 的 `AId` 设成 `int` 而非 `int?` | 无法区分“未设置”与“0” | 保持非可空即可，但代码里仍不手写值 |

---

### 结论  
按口诀写代码，模型配置正确（一对多、复合主键、外键可写），EF Core 就能在最少的 SQL 语句里完成“主从一次性插入”，既安全又高效。