在 ASP.NET Core 里，**DTO 永远用 `record class`**，根本别考虑 `struct`。  
理由一句话：**DTO 是“只读数据容器”，不是“值”，不要让它继承值类型的全部缺陷**。

下面给出对比表，一眼看懂。

| 场景需求               | `record class` DTO     | `struct` DTO                                                                               |
| ---------------------- | ---------------------- | ------------------------------------------------------------------------------------------ |
| 默认不可变             | ✅ init-only 属性       | ❌ 要自己写 `readonly struct` 才能模拟                                                      |
| 无参序列化构造函数     | ✅ 编译器自动生成       | ❗ 必须显式给出，否则 System.Text.Json 反序列化失败                                         |
| 字段多、嵌套对象       | ✅ 引用类型，无复制开销 | ❌ 值类型，大结构体每次传递都是全字段拷贝，性能反而差                                       |
| 数组/列表里存 DTO      | ✅ 只拷贝引用           | ❌ 数组元素是值类型，每次访问都拷贝整个结构体                                               |
| 模型验证、EF Core 投影 | ✅ 直接支持             | ❌ 结构体是值类型，框架里很多场景会装箱或生成临时副本，验证器可能拿不到同一实例             |
| 与接口、泛型约束配合   | ✅ 无装箱               | ❗ 一旦转成接口就装箱，高频调用 GC 压力陡增                                                 |
| 相等语义               | ✅ 按内容 Equals        | ✅ 也可按内容，但值语义通常不是你想要的（两个 DTO 只要字段相同就相等，与引用无关）          |
| 热路径性能             | 现代 GC + 对象池足够快 | 理论上省分配，但 DTO 通常是短命对象，GC 分代回收比避免分配更重要；且结构体拷贝代价反而更高 |

一句话总结：  
**DTO 的使命是“跨边界搬运数据”，不是“做数学值”。**  
`record class` 给出不可变、低样板、序列化友好的语法，同时让运行时无拷贝、无装箱；  
`struct` 带来的只是“省一次分配”，却换来成倍的拷贝、反序列化限制、模型验证坑，**血亏**。

结论  
ASP.NET Core 项目里，DTO 统一写成：

```csharp
public sealed record UserDto(int Id, string Name, string Email);
```

除非你能拿出 profiling 数据证明这里**每秒几十万次分配且 GC 成为瓶颈**，否则永远不要把它改成 `struct`。