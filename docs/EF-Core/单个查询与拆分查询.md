
## EF Core 单 `Include` 拆分查询原理

> 一条 `Blog ↔ 10 000 Posts` 的完整拆解

---

## 1. 不拆分时的“笛卡尔爆炸”

```sql
-- 单条 SQL
SELECT b.BlogId, b.Name, b.Url,           -- 主表 3 列
       p.PostId, p.Title, p.Content       -- 子表 3 列
FROM Blogs AS b
LEFT JOIN Posts AS p ON b.BlogId = p.BlogId
WHERE b.BlogId = 1;
```

结果：1 行 Blog 重复 10 000 次 → **网络包膨胀、内存浪费**。

---

## 2. 启用拆分查询

```csharp
var blog = await ctx.Blogs
                    .Include(b => b.Posts)
                    .AsSplitQuery()          // 关键
                    .FirstOrDefaultAsync(b => b.BlogId == 1);
```

EF 在同一事务里连续发两条 SQL：

### ① 主表
```sql
SELECT b.BlogId, b.Name, b.Url
FROM Blogs AS b
WHERE b.BlogId = 1;
-- 返回 1 行
```

### ② 子表
```sql
SELECT p.PostId, p.BlogId, p.Title, p.Content
FROM Posts AS p
WHERE p.BlogId = 1;
-- 返回 10 000 行
```

---

## 3. 内存拼装

1. 第 ① 步：Blog 实体进入 **Identity Map**。  
2. 第 ② 步：按外键 `BlogId=1` 把 10 000 个 `Post` 填到 `blog.Posts`。

```csharp
blog.Posts = new List<Post> { 10_000 个实体 };
```

导航属性完整，主表列**仅传输 1 次**。

---

## 4. 收益估算

| 模式   | 传输字节                              | 节省     |
| ------ | ------------------------------------- | -------- |
| 单 SQL | 200×10 000 + 100×10 000 ≈ **2.86 MB** | —        |
| 拆分   | 200×1 + 100×10 000 ≈ **0.98 MB**      | **66 %** |

---

## 5. 一句话总结

哪怕只有一个 `Include`，`.AsSplitQuery()` 也会生成“主表 1 条 SQL + 子表 1 条 SQL”，彻底避免主表列重复，显著减少冗余数据传输。
```